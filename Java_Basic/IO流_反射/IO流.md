# IO流

# 13.1 File 类的使用:常用构造器

![2021-06-27_16.38.10.png](/figures/2021-06-27_16.38.10.png)

![2021-06-27_16.38.31.png](/figures/2021-06-27_16.38.31.png)

不同系统下路径有区别。

![2021-06-27_16.57.41.png](/figures/2021-06-27_16.57.41.png)

![2021-06-27_17.25.59.png](/figures/2021-06-27_17.25.59.png)

# 13.2 IO流

![2021-06-27_22.47.10.png](/figures//figures/2021-06-27_22.47.10.png)

分类

![2021-06-29_11.52.21.png](/figures/2021-06-29_11.52.21.png)

访问文件是节点流，下面其余的都是处理流。

节点流:直接从数据源或目的地读写数据。

处理流:不直接连接到数据源或目的地，而是“连接”在已存 在的流(节点流或处理流)之上，通过对数据的处理为程序提 供更为强大的读写功能。

例子。

![2021-06-29_17.38.27.png](/figures/2021-06-29_17.38.27.png)

![2021-06-29_17.38.20.png](/figures/2021-06-29_17.38.20.png)

# 13.4 缓冲流

缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为:
- BufferedInputStream 和 BufferedOutputStream
- BufferedReader 和 BufferedWriter

注意点

 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区

 当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从
文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中
读取下一个8192个字节数组。

 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，
BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法
flush()可以强制将缓冲区的内容全部写入输出流

 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也
会相应关闭内层节点流

 flush()方法的使用:手动将buffer中内容写入文件

 如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷
新缓冲区，关闭后不能再写出

![2021-06-30_11.41.01.png](/figures/2021-06-30_11.41.01.png)

# 13.5 转换流

![2021-06-30_11.46.13.png](/figures/2021-06-30_11.46.13.png)

## 字符集

![2021-06-30_11.56.47.png](/figures/2021-06-30_11.56.47.png)

举例

![2021-06-30_12.30.46.png](/figures/2021-06-30_12.30.46.png)

编码:字符串 字节数组 

解码:字节数组 字符串

# 13-6 标准输入、输出流

![2021-06-30_12.44.12.png](/figures/2021-06-30_12.44.12.png)

# 13-7 打印流

![2021-06-30_12.44.20.png](/figures/2021-06-30_12.44.20.png)

# 13-8 数据流

![2021-06-30_13.06.23.png](/figures/2021-06-30_13.06.23.png)

# 13-9 对象流

 ObjectInputStream和OjbectOutputSteam
 用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可

以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。

-  序列化:用ObjectOutputStream类保存基本类型数据或对象的机制
-  反序列化:用ObjectInputStream类读取基本类型数据或对象的机制
-  ObjectOutputStream和ObjectInputStream不能序列化static和transient修
饰的成员变量

对象序列化机制：允许把内存中的Java对象转换成平台无关的二进制流，从 而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传 输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象

![2021-07-02_21.58.59.png](/figures/2021-07-02_21.58.59.png)

凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量:

private static final long serialVersionUID;

serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象
进行版本控制，有关各版本反序列化时是否兼容。

如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自
动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，
显式声明。

简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验 证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的 serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同 就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异 常。(InvalidCastException)

# 13-10 随机存取文件流

![2021-07-02_23.41.38.png](/figures/2021-07-02_23.41.38.png)

# 13-11 NIO.2中Path、 Paths、Files类的使用